<html>
<body>
	<div id="info"></div>
	<style>
	canvas {
		border: 1px solid #ddd;
	}
	</style>
	<script>THREE = {}</script>
	<script src="Vector3.js"></script>
	<script src="Curve.js"></script>
	<script src="CatmullRomCurve3.js"></script>
	<script>

		var info = document.querySelector('#info');
		var canvas = document.createElement('canvas');
		canvas.width = 1024;
		canvas.height = 1024;
		var DIVISONS = 200;

		var ctx = canvas.getContext('2d');

		document.body.appendChild(canvas);

		var needRedraw = true;

		var points = [];
		var curve = new THREE.CatmullRomCurve3(points);


		THREE.SplineCurve3 = THREE.Curve.create(

			function ( points /* array of Vector3 */) {

				this.points = ( points == undefined ) ? [] : points;

			},

			function ( t ) {

				var points = this.points;
				var point = ( points.length - 1 ) * t;

				var intPoint = Math.floor( point );
				var weight = point - intPoint;

				var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
				var point1 = points[ intPoint ];
				var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
				var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

				var vector = new THREE.Vector3();

				vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
				vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
				vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

				return vector;

			}

		);

		var curve2 = new THREE.SplineCurve3(points);

		for (i=0; i < 4; i++) {
			points.push( new THREE.Vector3(Math.random() * canvas.width, Math.random() * canvas.width, 0))
		}

		document.addEventListener('mousemove', function(e) {
			info.innerHTML = e.offsetX + ',' + e.offsetY;

			if (mouseOn) {
				mouseOn.x = e.offsetX;
				mouseOn.y = e.offsetY;
			} else {
				if(detectHit(e.offsetX, e.offsetY)) {
					canvas.style.cursor = 'pointer';
				} else {
					canvas.style.cursor = 'default';
				}
			}

			needRedraw = true;
		
		});

		var mouseOn = null;

		document.addEventListener('mousedown', function(e) {

			var point = detectHit(e.offsetX, e.offsetY);

			// TODO insert new points

			mouseOn = point;

			needRedraw = true;

		});

		document.addEventListener('mouseup', function(e) {
			if (!mouseOn) return;
			mouseOn.x = e.offsetX;
			mouseOn.y = e.offsetY;
			mouseOn = null;
			needRedraw = true;
		});

		function drawCircle(x, y, size) {
			ctx.beginPath();
			ctx.arc(x, y, size, 0, Math.PI * 2);
		}

		function detectHit(x, y) {
			for (var i=0;i<points.length;i++) {
				point = points[i];
				drawCircle(point.x, point.y, 10);
				if (ctx.isPointInPath(x, y)) {
					return point;
				}
			}

			return null;
		}		

		function draw() {

			requestAnimationFrame(draw);

			// if (needRedraw) {

				ctx.clearRect(0, 0, canvas.width, canvas.height);
				
				ctx.fillStyle = '#aaa';

				for (var i=0;i<points.length;i++) {
					point = points[i];
					drawCircle(point.x, point.y, 10);
					ctx.fill();
				}

				ctx.lineWidth = 3;

				ctx.beginPath();
				for (var i=0;i<=DIVISONS;i++) {
					point = window.spline ? curve2.getPoint(i / DIVISONS) : curve.getPoint(i / DIVISONS);
					if (i==0) ctx.moveTo(point.x, point.y);
					else ctx.lineTo(point.x, point.y);
				}

				ctx.stroke();

			// }

			needRedraw = false;
		}

		draw();

	</script>
</body>
</html>